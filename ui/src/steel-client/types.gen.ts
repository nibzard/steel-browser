// This file is auto-generated by @hey-api/openapi-ts

export type ScrapeRequest = {
  url?: string;
  format?: Array<"html" | "readability" | "cleaned_html" | "markdown">;
  screenshot?: boolean;
  pdf?: boolean;
  /**
   * Proxy URL to use for the scrape. Provide `null` to disable proxy. If not provided, current session proxy settings will be used.
   */
  proxyUrl?: string | null;
  delay?: number;
  logUrl?: string;
};

export type ScrapeResponse = {
  content: {
    [key: string]: unknown;
  };
  metadata: {
    title?: string;
    language?: string;
    urlSource?: string;
    timestamp?: Date;
    description?: string;
    keywords?: string;
    author?: string;
    ogTitle?: string;
    ogDescription?: string;
    ogImage?: string;
    ogUrl?: string;
    ogSiteName?: string;
    articleAuthor?: string;
    publishedTime?: string;
    modifiedTime?: string;
    canonical?: string;
    favicon?: string;
    jsonLd?: unknown;
    statusCode: number;
  };
  links: Array<{
    url: string;
    text: string;
  }>;
  screenshot?: string;
  pdf?: string;
};

export type ScreenshotRequest = {
  url?: string;
  /**
   * Proxy URL to use for the scrape. Provide `null` to disable proxy. If not provided, current session proxy settings will be used.
   */
  proxyUrl?: string | null;
  delay?: number;
  fullPage?: boolean;
  logUrl?: string;
};

export type ScreenshotResponse = unknown;

export type PDFRequest = {
  url?: string;
  /**
   * Proxy URL to use for the scrape. Provide `null` to disable proxy. If not provided, current session proxy settings will be used.
   */
  proxyUrl?: string | null;
  delay?: number;
  logUrl?: string;
};

export type PDFResponse = unknown;

export type CreateSession = {
  /**
   * Unique identifier for the session
   */
  sessionId?: string;
  /**
   * Proxy URL to use for the session
   */
  proxyUrl?: string;
  /**
   * User agent string to use for the session
   */
  userAgent?: string;
  /**
   * Session context data to be used in the created session
   */
  sessionContext?: {
    /**
     * Cookies to initialize in the session
     */
    cookies?: Array<{
      /**
       * The name of the cookie
       */
      name: string;
      /**
       * The value of the cookie
       */
      value: string;
      /**
       * The URL of the cookie
       */
      url?: string;
      /**
       * The domain of the cookie
       */
      domain?: string;
      /**
       * The path of the cookie
       */
      path?: string;
      /**
       * Whether the cookie is secure
       */
      secure?: boolean;
      /**
       * Whether the cookie is HTTP only
       */
      httpOnly?: boolean;
      /**
       * The same site attribute of the cookie
       */
      sameSite?: "Strict" | "Lax" | "None";
      /**
       * The size of the cookie
       */
      size?: number;
      /**
       * The expiration date of the cookie
       */
      expires?: number;
      /**
       * The partition key of the cookie
       */
      partitionKey?: {
        /**
         * The site of the top-level URL the browser was visiting at the start of the request to the endpoint that set the cookie.
         */
        topLevelSite: string;
        /**
         * Indicates if the cookie has any ancestors that are cross-site to the topLevelSite.
         */
        hasCrossSiteAncestor: boolean;
      };
      /**
       * Whether the cookie is a session cookie
       */
      session?: boolean;
      /**
       * The priority of the cookie
       */
      priority?: "Low" | "Medium" | "High";
      /**
       * Whether the cookie is a same party cookie
       */
      sameParty?: boolean;
      /**
       * The source scheme of the cookie
       */
      sourceScheme?: "Unset" | "NonSecure" | "Secure";
      /**
       * The source port of the cookie
       */
      sourcePort?: number;
    }>;
    /**
     * Domain-specific localStorage items to initialize in the session
     */
    localStorage?: {
      [key: string]: {
        [key: string]: string;
      };
    };
    /**
     * Domain-specific sessionStorage items to initialize in the session
     */
    sessionStorage?: {
      [key: string]: {
        [key: string]: string;
      };
    };
    /**
     * Domain-specific indexedDB items to initialize in the session
     */
    indexedDB?: {
      [key: string]: Array<{
        id: number;
        name: string;
        data: Array<{
          id: number;
          name: string;
          records: Array<{
            key?: unknown;
            value?: unknown;
            blobFiles?: Array<{
              blobNumber: number;
              mimeType: string;
              size: number;
              filename?: string;
              lastModified?: Date;
              path?: string;
            }>;
          }>;
        }>;
      }>;
    };
  };
  /**
   * Indicates if Selenium is used in the session
   */
  isSelenium?: boolean;
  /**
   * Flag to indicate if ads should be blocked in the session
   */
  blockAds?: boolean;
  /**
   * Enable bandwidth optimizations. Passing true enables all flags (except hosts/patterns). Object allows granular control.
   */
  optimizeBandwidth?:
    | boolean
    | {
        blockImages?: boolean;
        blockMedia?: boolean;
        blockStylesheets?: boolean;
        blockHosts?: Array<string>;
        blockUrlPatterns?: Array<string>;
      };
  /**
   * Flag to indicate if fingerprint injection should be skipped for this session.
   */
  skipFingerprintInjection?: boolean;
  /**
   * Device configuration for the session. Specify 'mobile' for mobile device fingerprints and configurations.
   */
  deviceConfig?: {
    device?: "desktop" | "mobile";
  };
  /**
   * Deprecated: Log sink URL to use for the session
   */
  logSinkUrl?: string;
  /**
   * Extensions to use for the session
   */
  extensions?: Array<string>;
  /**
   * Flag to indicate if session should be persisted
   */
  persist?: boolean;
  /**
   * User data directory path to use for the session
   */
  userDataDir?: string;
  /**
   * Timezone to use for the session
   */
  timezone?: string;
  /**
   * Dimensions to use for the session
   */
  dimensions?: {
    width: number;
    height: number;
  };
  /**
   * Chrome user preferences to customize browser behavior (e.g., font size, popup blocking, notification settings)
   */
  userPreferences?: {
    [key: string]: unknown;
  };
  /**
   * Extra metadata to help initialize the session
   */
  extra?: {
    [key: string]: unknown;
  };
  /**
   * Configuration for session credentials
   */
  credentials?: {
    autoSubmit?: boolean | unknown;
    blurFields?: boolean | unknown;
    exactOrigin?: boolean | unknown;
  };
  /**
   * Headless mode for the session
   */
  headless?: boolean;
};

export type device = "desktop" | "mobile";

export const device = {
  DESKTOP: "desktop",
  MOBILE: "mobile",
} as const;

export type SessionDetails = {
  /**
   * Unique identifier for the session
   */
  id: string;
  /**
   * Timestamp when the session started
   */
  createdAt: Date;
  /**
   * Status of the session
   */
  status: "idle" | "live" | "released" | "failed";
  /**
   * Duration of the session in milliseconds
   */
  duration: number;
  /**
   * Number of events processed in the session
   */
  eventCount: number;
  /**
   * Dimensions used for the session
   */
  dimensions?: {
    width: number;
    height: number;
  };
  /**
   * Session timeout duration in milliseconds
   */
  timeout: number;
  /**
   * Amount of credits consumed by the session
   */
  creditsUsed: number;
  /**
   * URL for the session's WebSocket connection
   */
  websocketUrl: string;
  /**
   * URL for a viewing the live browser instance for the session
   */
  debugUrl: string;
  /**
   * URL for debugging the session
   */
  debuggerUrl: string;
  /**
   * URL to view session details
   */
  sessionViewerUrl: string;
  /**
   * User agent string used in the session
   */
  userAgent?: string;
  /**
   * Proxy server used for the session
   */
  proxy?: string;
  /**
   * Amount of data transmitted through the proxy
   */
  proxyTxBytes: number;
  /**
   * Amount of data received through the proxy
   */
  proxyRxBytes: number;
  /**
   * Indicates if captcha solving is enabled
   */
  solveCaptcha?: boolean;
  /**
   * Indicates if Selenium is used in the session
   */
  isSelenium?: boolean;
};

/**
 * Status of the session
 */
export type status = "idle" | "live" | "released" | "failed";

/**
 * Status of the session
 */
export const status = {
  IDLE: "idle",
  LIVE: "live",
  RELEASED: "released",
  FAILED: "failed",
} as const;

export type MultipleSessions = {
  sessions: Array<{
    /**
     * Unique identifier for the session
     */
    id: string;
    /**
     * Timestamp when the session started
     */
    createdAt: Date;
    /**
     * Status of the session
     */
    status: "idle" | "live" | "released" | "failed";
    /**
     * Duration of the session in milliseconds
     */
    duration: number;
    /**
     * Number of events processed in the session
     */
    eventCount: number;
    /**
     * Dimensions used for the session
     */
    dimensions?: {
      width: number;
      height: number;
    };
    /**
     * Session timeout duration in milliseconds
     */
    timeout: number;
    /**
     * Amount of credits consumed by the session
     */
    creditsUsed: number;
    /**
     * URL for the session's WebSocket connection
     */
    websocketUrl: string;
    /**
     * URL for a viewing the live browser instance for the session
     */
    debugUrl: string;
    /**
     * URL for debugging the session
     */
    debuggerUrl: string;
    /**
     * URL to view session details
     */
    sessionViewerUrl: string;
    /**
     * User agent string used in the session
     */
    userAgent?: string;
    /**
     * Proxy server used for the session
     */
    proxy?: string;
    /**
     * Amount of data transmitted through the proxy
     */
    proxyTxBytes: number;
    /**
     * Amount of data received through the proxy
     */
    proxyRxBytes: number;
    /**
     * Indicates if captcha solving is enabled
     */
    solveCaptcha?: boolean;
    /**
     * Indicates if Selenium is used in the session
     */
    isSelenium?: boolean;
  }>;
};

export type SessionContextSchema = {
  /**
   * Cookies to initialize in the session
   */
  cookies?: Array<{
    /**
     * The name of the cookie
     */
    name: string;
    /**
     * The value of the cookie
     */
    value: string;
    /**
     * The URL of the cookie
     */
    url?: string;
    /**
     * The domain of the cookie
     */
    domain?: string;
    /**
     * The path of the cookie
     */
    path?: string;
    /**
     * Whether the cookie is secure
     */
    secure?: boolean;
    /**
     * Whether the cookie is HTTP only
     */
    httpOnly?: boolean;
    /**
     * The same site attribute of the cookie
     */
    sameSite?: "Strict" | "Lax" | "None";
    /**
     * The size of the cookie
     */
    size?: number;
    /**
     * The expiration date of the cookie
     */
    expires?: number;
    /**
     * The partition key of the cookie
     */
    partitionKey?: {
      /**
       * The site of the top-level URL the browser was visiting at the start of the request to the endpoint that set the cookie.
       */
      topLevelSite: string;
      /**
       * Indicates if the cookie has any ancestors that are cross-site to the topLevelSite.
       */
      hasCrossSiteAncestor: boolean;
    };
    /**
     * Whether the cookie is a session cookie
     */
    session?: boolean;
    /**
     * The priority of the cookie
     */
    priority?: "Low" | "Medium" | "High";
    /**
     * Whether the cookie is a same party cookie
     */
    sameParty?: boolean;
    /**
     * The source scheme of the cookie
     */
    sourceScheme?: "Unset" | "NonSecure" | "Secure";
    /**
     * The source port of the cookie
     */
    sourcePort?: number;
  }>;
  /**
   * Domain-specific localStorage items to initialize in the session
   */
  localStorage?: {
    [key: string]: {
      [key: string]: string;
    };
  };
  /**
   * Domain-specific sessionStorage items to initialize in the session
   */
  sessionStorage?: {
    [key: string]: {
      [key: string]: string;
    };
  };
  /**
   * Domain-specific indexedDB items to initialize in the session
   */
  indexedDB?: {
    [key: string]: Array<{
      id: number;
      name: string;
      data: Array<{
        id: number;
        name: string;
        records: Array<{
          key?: unknown;
          value?: unknown;
          blobFiles?: Array<{
            blobNumber: number;
            mimeType: string;
            size: number;
            filename?: string;
            lastModified?: Date;
            path?: string;
          }>;
        }>;
      }>;
    }>;
  };
};

export type RecordedEvents = {
  /**
   * Events to emit
   */
  events: unknown[];
};

export type ReleaseSession = {
  /**
   * Unique identifier for the session
   */
  id: string;
  /**
   * Timestamp when the session started
   */
  createdAt: Date;
  /**
   * Status of the session
   */
  status: "idle" | "live" | "released" | "failed";
  /**
   * Duration of the session in milliseconds
   */
  duration: number;
  /**
   * Number of events processed in the session
   */
  eventCount: number;
  /**
   * Dimensions used for the session
   */
  dimensions?: {
    width: number;
    height: number;
  };
  /**
   * Session timeout duration in milliseconds
   */
  timeout: number;
  /**
   * Amount of credits consumed by the session
   */
  creditsUsed: number;
  /**
   * URL for the session's WebSocket connection
   */
  websocketUrl: string;
  /**
   * URL for a viewing the live browser instance for the session
   */
  debugUrl: string;
  /**
   * URL for debugging the session
   */
  debuggerUrl: string;
  /**
   * URL to view session details
   */
  sessionViewerUrl: string;
  /**
   * User agent string used in the session
   */
  userAgent?: string;
  /**
   * Proxy server used for the session
   */
  proxy?: string;
  /**
   * Amount of data transmitted through the proxy
   */
  proxyTxBytes: number;
  /**
   * Amount of data received through the proxy
   */
  proxyRxBytes: number;
  /**
   * Indicates if captcha solving is enabled
   */
  solveCaptcha?: boolean;
  /**
   * Indicates if Selenium is used in the session
   */
  isSelenium?: boolean;
  /**
   * Indicates if the session was successfully released
   */
  success: boolean;
};

export type SessionStreamQuery = {
  /**
   * Show controls in the browser iframe
   */
  showControls?: boolean;
  /**
   * Theme of the browser iframe
   */
  theme?: "dark" | "light";
  /**
   * Make the browser iframe interactive
   */
  interactive?: boolean;
  /**
   * Page ID to connect to
   */
  pageId?: string;
  /**
   * Page index (or tab index) to connect to
   */
  pageIndex?: string;
};

/**
 * Theme of the browser iframe
 */
export type theme = "dark" | "light";

/**
 * Theme of the browser iframe
 */
export const theme = {
  DARK: "dark",
  LIGHT: "light",
} as const;

/**
 * HTML content for the session streamer view
 */
export type SessionStreamResponse = string;

export type SessionLiveDetailsResponse = {
  sessionViewerUrl: string;
  sessionViewerFullscreenUrl: string;
  websocketUrl: string;
  pages: Array<{
    id: string;
    url: string;
    title: string;
    favicon: string | null;
  }>;
  browserState: {
    status: "idle" | "live" | "released" | "failed";
    userAgent: string;
    browserVersion: string;
    initialDimensions: {
      width: number;
      height: number;
    };
    pageCount: number;
  };
};

export type LogQuerySchema = {
  startTime?: Date;
  endTime?: Date;
  eventTypes?: string;
  pageId?: string;
  targetType?: string;
  limit?: number;
  offset?: number;
};

export type LogStatsSchema = {
  totalEvents: number;
  oldestEvent: Date | null;
  newestEvent: Date | null;
  sizeBytes: number;
};

export type LogQueryResultSchema = {
  events: Array<{
    [key: string]: unknown;
  }>;
  total: number;
  hasMore: boolean;
};

export type ExportLogsSchema = {
  query?: {
    startTime?: Date;
    endTime?: Date;
    eventTypes?: string;
    pageId?: string;
    targetType?: string;
    limit?: number;
    offset?: number;
  };
};

export type GetDevtoolsUrlSchema = {
  pageId?: string;
};

export type LaunchRequest = {
  options: {
    args?: Array<string>;
    chromiumSandbox?: boolean;
    devtools?: boolean;
    downloadsPath?: string;
    headless?: boolean;
    ignoreDefaultArgs?: boolean | Array<string>;
    proxyUrl?: string;
    timeout?: number;
    tracesDir?: string;
  };
  req?: unknown;
  stealth?: boolean;
  cookies?: unknown[];
  userAgent?: string;
  extensions?: Array<string>;
  /**
   * Deprecated
   */
  logSinkUrl?: string;
  customHeaders?: {
    [key: string]: string;
  };
  timezone?: string;
  dimensions?: {
    width: number;
    height: number;
  } | null;
};

export type LaunchResponse = {
  success: boolean;
};

export type FileUploadRequest = {
  /**
   * The file to upload (binary) or URL string to download from
   */
  file?: unknown;
  /**
   * Path to the file in the storage system
   */
  path?: string;
};

export type FileDetails = {
  /**
   * Path to the file in the storage system
   */
  path: string;
  /**
   * Size of the file in bytes
   */
  size: number;
  /**
   * Timestamp when the file was last updated
   */
  lastModified: Date;
};

export type MultipleFiles = {
  /**
   * Array of files for the current page
   */
  data: Array<{
    /**
     * Path to the file in the storage system
     */
    path: string;
    /**
     * Size of the file in bytes
     */
    size: number;
    /**
     * Timestamp when the file was last updated
     */
    lastModified: Date;
  }>;
};

export type ScrapeData = {
  body?: ScrapeRequest;
};

export type ScrapeResponse2 = ScrapeResponse;

export type ScrapeError = unknown;

export type ScreenshotData = {
  body?: ScreenshotRequest;
};

export type ScreenshotResponse2 = ScreenshotResponse;

export type ScreenshotError = unknown;

export type PdfData = {
  body?: PDFRequest;
};

export type PdfResponse = PDFResponse;

export type PdfError = unknown;

export type HealthResponse = unknown;

export type HealthError = unknown;

export type LaunchBrowserSessionData = {
  body?: CreateSession;
};

export type LaunchBrowserSessionResponse = SessionDetails;

export type LaunchBrowserSessionError = unknown;

export type GetSessionsResponse = MultipleSessions;

export type GetSessionsError = unknown;

export type GetSessionDetailsData = {
  path: {
    sessionId: string;
  };
};

export type GetSessionDetailsResponse = SessionDetails;

export type GetSessionDetailsError = unknown;

export type GetBrowserContextData = {
  path: {
    sessionId: string;
  };
};

export type GetBrowserContextResponse = SessionContextSchema;

export type GetBrowserContextError = unknown;

export type ReleaseBrowserSessionData = {
  path: {
    sessionId: string;
  };
};

export type ReleaseBrowserSessionResponse = ReleaseSession;

export type ReleaseBrowserSessionError = unknown;

export type ReleaseBrowserSessionsResponse = ReleaseSession;

export type ReleaseBrowserSessionsError = unknown;

export type GetSessionDebuggerStreamData = {
  query?: {
    /**
     * Make the browser iframe interactive
     */
    interactive?: boolean;
    /**
     * Page ID to connect to
     */
    pageId?: string;
    /**
     * Page index (or tab index) to connect to
     */
    pageIndex?: string;
    /**
     * Show controls in the browser iframe
     */
    showControls?: boolean;
    /**
     * Theme of the browser iframe
     */
    theme?: "dark" | "light";
  };
};

export type GetSessionDebuggerStreamResponse = SessionStreamResponse;

export type GetSessionDebuggerStreamError = unknown;

export type ReceiveEventsData = {
  body?: RecordedEvents;
};

export type ReceiveEventsResponse = unknown;

export type ReceiveEventsError = unknown;

export type GetSessionLiveDetailsData = {
  path: {
    id: string;
  };
};

export type GetSessionLiveDetailsResponse = SessionLiveDetailsResponse;

export type GetSessionLiveDetailsError = unknown;

export type ScrapeSessionData = {
  body?: ScrapeRequest;
};

export type ScrapeSessionResponse = ScrapeResponse;

export type ScrapeSessionError = unknown;

export type ScreenshotSessionData = {
  body?: ScreenshotRequest;
};

export type ScreenshotSessionResponse = ScreenshotResponse;

export type ScreenshotSessionError = unknown;

export type PdfSessionData = {
  body?: PDFRequest;
};

export type PdfSessionResponse = PDFResponse;

export type PdfSessionError = unknown;

export type GetDevtoolsUrlData = {
  query?: {
    pageId?: string;
  };
};

export type GetDevtoolsUrlResponse = unknown;

export type GetDevtoolsUrlError = unknown;

export type UploadFileData = {
  body?: FileUploadRequest;
  path: {
    sessionId: string;
  };
};

export type UploadFileResponse = FileDetails;

export type UploadFileError = unknown;

export type ListFilesData = {
  path: {
    sessionId: string;
  };
};

export type ListFilesResponse = MultipleFiles;

export type ListFilesError = unknown;

export type DeleteAllFilesData = {
  path: {
    sessionId: string;
  };
};

export type DeleteAllFilesResponse = void;

export type DeleteAllFilesError = unknown;

export type DownloadFileData = {
  path: {
    "*": string;
    sessionId: string;
  };
};

export type DownloadFileResponse = unknown;

export type DownloadFileError = unknown;

export type DeleteFileData = {
  path: {
    "*": string;
    sessionId: string;
  };
};

export type DeleteFileResponse = void;

export type DeleteFileError = unknown;

export type DownloadArchiveData = {
  path: {
    sessionId: string;
  };
};

export type DownloadArchiveResponse = unknown;

export type DownloadArchiveError = unknown;

export type GetV1LogsQueryData = {
  query?: {
    endTime?: Date;
    eventTypes?: string;
    limit?: number;
    offset?: number;
    pageId?: string;
    startTime?: Date;
    targetType?: string;
  };
};

export type GetV1LogsQueryResponse = unknown;

export type GetV1LogsQueryError = unknown;

export type GetV1LogsStatsResponse = unknown;

export type GetV1LogsStatsError = unknown;

export type GetV1LogsStreamResponse = unknown;

export type GetV1LogsStreamError = unknown;

export type PostV1LogsExportData = {
  query?: {
    endTime?: Date;
    eventTypes?: string;
    limit?: number;
    offset?: number;
    pageId?: string;
    startTime?: Date;
    targetType?: string;
  };
};

export type PostV1LogsExportResponse = unknown;

export type PostV1LogsExportError = unknown;

export type DeleteV1LogsResponse = unknown;

export type DeleteV1LogsError = unknown;

export type ScrapeResponseTransformer = (data: any) => Promise<ScrapeResponse>;

export type ScrapeResponseModelResponseTransformer = (
  data: any,
) => ScrapeResponse;

export const ScrapeResponseModelResponseTransformer: ScrapeResponseModelResponseTransformer =
  (data) => {
    if (data?.metadata?.timestamp) {
      data.metadata.timestamp = new Date(data.metadata.timestamp);
    }
    return data;
  };

export const ScrapeResponseTransformer: ScrapeResponseTransformer = async (
  data,
) => {
  ScrapeResponseModelResponseTransformer(data);
  return data;
};

export type LaunchBrowserSessionResponseTransformer = (
  data: any,
) => Promise<LaunchBrowserSessionResponse>;

export type SessionDetailsModelResponseTransformer = (
  data: any,
) => SessionDetails;

export const SessionDetailsModelResponseTransformer: SessionDetailsModelResponseTransformer =
  (data) => {
    if (data?.createdAt) {
      data.createdAt = new Date(data.createdAt);
    }
    return data;
  };

export const LaunchBrowserSessionResponseTransformer: LaunchBrowserSessionResponseTransformer =
  async (data) => {
    SessionDetailsModelResponseTransformer(data);
    return data;
  };

export type GetSessionDetailsResponseTransformer = (
  data: any,
) => Promise<GetSessionDetailsResponse>;

export const GetSessionDetailsResponseTransformer: GetSessionDetailsResponseTransformer =
  async (data) => {
    SessionDetailsModelResponseTransformer(data);
    return data;
  };

export type ReleaseBrowserSessionResponseTransformer = (
  data: any,
) => Promise<ReleaseBrowserSessionResponse>;

export type ReleaseSessionModelResponseTransformer = (
  data: any,
) => ReleaseSession;

export const ReleaseSessionModelResponseTransformer: ReleaseSessionModelResponseTransformer =
  (data) => {
    if (data?.createdAt) {
      data.createdAt = new Date(data.createdAt);
    }
    return data;
  };

export const ReleaseBrowserSessionResponseTransformer: ReleaseBrowserSessionResponseTransformer =
  async (data) => {
    ReleaseSessionModelResponseTransformer(data);
    return data;
  };

export type ReleaseBrowserSessionsResponseTransformer = (
  data: any,
) => Promise<ReleaseBrowserSessionsResponse>;

export const ReleaseBrowserSessionsResponseTransformer: ReleaseBrowserSessionsResponseTransformer =
  async (data) => {
    ReleaseSessionModelResponseTransformer(data);
    return data;
  };

export type ScrapeSessionResponseTransformer = (
  data: any,
) => Promise<ScrapeSessionResponse>;

export const ScrapeSessionResponseTransformer: ScrapeSessionResponseTransformer =
  async (data) => {
    ScrapeResponseModelResponseTransformer(data);
    return data;
  };

export type UploadFileResponseTransformer = (
  data: any,
) => Promise<UploadFileResponse>;

export type FileDetailsModelResponseTransformer = (data: any) => FileDetails;

export const FileDetailsModelResponseTransformer: FileDetailsModelResponseTransformer =
  (data) => {
    if (data?.lastModified) {
      data.lastModified = new Date(data.lastModified);
    }
    return data;
  };

export const UploadFileResponseTransformer: UploadFileResponseTransformer =
  async (data) => {
    FileDetailsModelResponseTransformer(data);
    return data;
  };
